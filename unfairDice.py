# ---------------------------------------------------
#    Name: FATIMA REHMATULLAH
#    ID: 1631703
#    CMPUT 274, Fall  2020
#    Weekly Assignment#2: UnfairDice
# --------------------------------------------------
#the code uses the inbuilt random function
import random

def biased_rolls(prob_list, s, n):
    
    """ Simulate n rolls of a biased m-sided die and return
    a list containing the results. 

    Arguments:
        prob_list: a list of the probabilities of rolling the 
                   number on each side of the m-sided die. The list  
                   will always have the length m (m >= 2), where m is 
                   the number of sides numbered 1 to m. Therefore,  
                   for example, the probability stored at index 0 in 
                   the list is the probability of rolling a 1 on
                   the m-sided die.
        s: the seed to use when initializing the PRNG
        n: the number of rolls to return

    Return:
        rolls: a list (of length n) containing each of the n rolls of the 
               biased die, in the order they were generated.
    """
    
    # replace this line and solve the problem!

    #assigns and initializes variables
    #rolls and intervals is appended as the code runs forward
    s = int(s)
    n = int(n)
    random_number = 0
    rolls = []
    interval = []
    i = 0

    #uses the given probabilities to make a new list interval
    #the first value is assigned zero

    interval.append(0)
    for i in range(len(prob_list)):
        interval.append(interval[i]+prob_list[i])
        i = i+1

    #assigns the argument s value to the seed for use in the random function

    random.seed(s)

    #in order to check the interval in which
    #the probability lies, the code generates
    #random numbers (one each for every throw)

    for i in range(n):
        random_number = random.random()
        flag = False
        j = 0

        #the code checks and records the interval in which 
        #the random number lies in a new list called rolls
        #the value appended is index+1 since the list index starts with zero
        while flag == False and j != len(prob_list)+1:
            if interval[j] < random_number <= interval[j+1]:
                flag = True
                rolls.append(j+1)
            j = j+1
        #returs the list rolls just created
    return(rolls)
pass

    # return the resulting rolls



def draw_histogram(m, rolls, width):

    """ Draws a frequency histogram of the rolls of an m-sided die
    mapped to a fixed width.

    Arguments: 
        m (int): the number of sides on the die
        rolls (list): the list of rolls generated by the biased die
        width (int): the fixed width of the histogram, in characters
                     (this is the length of the longest bar in the 
                     histogram, to maximize space in the chart)

    Returns:
        None (but prints the histogram to standard output)
    """
    # solve the problem here by replacing the pass keyword

    #prints the heading
    #creates a new list count which is a list of
    #the frequencies(number of times each side has been rolled)
    print("Frequency Histogram:",f'{m}-sided Die')
    count = []
    for i in range(m):
        count.append(0)
    for i in range(m+1):
        for j in range(len(rolls)):
            if i == rolls[j-1]:
                count[i-1] = count[i-1] + 1

    #the code finds the largest frequency to use it
    #scale the other frequencies based on its legnth
    #and the value of the width
    #the code uses a simple proportion method to scale

    largest = max(count)
    frequencydensity = []
    for m in count:
        frequencydensity.append(round((m*width)/largest))
    #the for loop prints # for the frequencydensity 
    #and - to cover the rest of the legnth of the width
    for k in range(len(count)):
        print(f'{k+1}.{"#" * frequencydensity[k]}{"-" * (width-frequencydensity[k])}')
    #function directly prints the histogram. Nothing returned
    return None


    # this function should print to standard output
    # you should not return anything!


if __name__ == "__main__":
    # Any code indented under this line will only be run
    # when the program is called directly from the terminal
    # using "python3 unfairDice.py". This can be useful for
    # testing your implementations.
    pass

